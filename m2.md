# M2 Implementation Outline: BWISC Signal Engine & Risk Management

## Overview
M2 implements the core BWISC (Burst-Weighted Imbalance with Session Confluence) signal engine, session statistics, risk sizing with equity caps, margin guards, position caps, and budget gates.

## Core M2 Requirements from finalspec.md
- **Signal Engine (BWISC)**: BTR/SDR/ORE/Bias calculations
- **Session stats**: OR levels, ATR(D1), MA20(H1), RSI(H1)  
- **Risk sizing with equity caps**: ATR-based SL/TP, volume calculation
- **Margin guard**: ≤60% free margin protection
- **Position caps**: MaxOpenPositionsTotal/PerSymbol/PendingsPerSymbol
- **Budget gate**: Prevent trades exceeding daily/overall rooms

---

## 1. Indicators Module (`indicators.mqh`)

### 1.1 Initialize Real Indicator Handles
- **Replace stubs** in `Indicators_Init()`
- Create handles for each symbol:
  - `iATR(symbol, PERIOD_D1, 14)` - ATR(D1) for SL/TP scaling
  - `iMA(symbol, PERIOD_H1, 20, 0, MODE_EMA, PRICE_CLOSE)` - MA20(H1) for SDR
  - `iRSI(symbol, PERIOD_H1, 14, PRICE_CLOSE)` - RSI(H1) guard
- **Error handling**: Check for INVALID_HANDLE, retry logic
- **Storage**: Per-symbol indicator context struct

### 1.2 Implement Indicators_Refresh()
- **ATR(D1)**: Get current ATR value for SL/TP calculations
- **MA20(H1)**: Get current EMA(20) value for SDR calculation
- **RSI(H1)**: Get current RSI value for overextension guard
- **Error handling**: Handle insufficient data, calculation errors
- **Caching**: Store values in symbol context for reuse

### 1.3 Session Statistics Calculation
- **Opening Range (OR)**: First 60min (configurable) high/low on M5
  - Track session start time per symbol
  - Accumulate H/L during OR window
  - Store OR_High, OR_Low for BC setup calculations
- **Yesterday's D1 OHLC**: For BTR calculation
  - Get previous D1 bar: Open[1], High[1], Low[1], Close[1]
  - Handle weekend gaps and missing data

---

## 2. BWISC Signal Engine (`signals_bwisc.mqh`)

### 2.1 Core Calculations Implementation

#### BTR (Body-to-TrueRange)
```cpp
// Formula: |C[1]-O[1]| / max(H[1]-L[1], point)
double BTR = MathAbs(Close[1] - Open[1]) / MathMax(High[1] - Low[1], _Point);
```

#### SDR (Session Dislocation Ratio) 
```cpp
// Formula: |Open_LO - MA20_H1| / ATR(D1)
double SDR = MathAbs(session_open - ma20_h1) / atr_d1;
```

#### ORE (Opening Range Energy)
```cpp
// Formula: range(H-L) / ATR(D1) during first 60m
double ORE = (or_high - or_low) / atr_d1;
```

### 2.2 Bias Score Calculation
```cpp
// Formula from spec: Bias = 0.45*sign(C1−O1)*BTR + 0.35*sign(Open_LO − MA20_H1)*min(SDR,1) + 0.20*sign(C1−O1)*min(ORE,1)
double bias = 0.45 * MathSign(Close[1] - Open[1]) * BTR +
              0.35 * MathSign(session_open - ma20_h1) * MathMin(SDR, 1.0) +
              0.20 * MathSign(Close[1] - Open[1]) * MathMin(ORE, 1.0);
```

### 2.3 Setup Detection Logic

#### BC (Breakout Continuation) Setup
- **Trigger**: `|Bias| ≥ 0.6`
- **Entry**: Stop beyond OR extreme (OR_High + buffer for long, OR_Low - buffer for short)
- **SL**: `ATR(D1) * SLmult` from entry
- **TP**: `SL_distance * RtargetBC` (default 2.2R)
- **Direction**: Follow bias sign

#### MSC (Mean Reversion Setup) 
- **Trigger**: `|Bias| ∈ [0.35, 0.6) AND SDR ≥ 0.35`
- **Entry**: Limit toward MA20_H1 (fade the dislocation)
- **SL**: Beyond dislocation point
- **TP**: `SL_distance * RtargetMSC` (default 1.8-2.2R)
- **Direction**: Opposite to dislocation

### 2.4 RSI Guard Implementation
- **Overextension check**: RSI > 70 (overbought) or RSI < 30 (oversold)
- **Override condition**: Strong dislocation (SDR ≥ threshold) can override RSI guard
- **Integration**: Apply guard before final setup confirmation

### 2.5 SignalsBWISC_Propose() Complete Implementation
- **Input validation**: Check symbol, context validity
- **Calculation sequence**: BTR → SDR → ORE → Bias → Setup detection
- **Output population**: hasSetup, setupType, slPoints, tpPoints, bias, confidence
- **Confidence calculation**: `confidence = clamp(|Bias|, 0, 1)`
- **Error handling**: Return safe defaults on calculation failures

---

## 3. Risk Management (`risk.mqh`)

### 3.1 ATR-Based Position Sizing
```cpp
// Core sizing formula from spec:
// risk_money = equity * risk_pct
// sl_points = max(|entry - stop| / _Point, MinStopPoints)  
// value_per_point = (SYMBOL_TRADE_TICK_VALUE) / (SYMBOL_TRADE_TICK_SIZE / _Point)
// raw_volume = risk_money / (sl_points * value_per_point)
```

### 3.2 Volume Calculation Implementation
- **Risk money calculation**: `AccountEquity() * RiskPct / 100.0`
- **SL distance**: Convert ATR-based SL to points
- **Value per point**: Use symbol properties for accurate calculation
- **Volume normalization**: 
  - Round to `SYMBOL_VOLUME_STEP`
  - Respect `SYMBOL_VOLUME_MIN` and `SYMBOL_VOLUME_MAX`
  - Apply leverage limits (1:50 FX, 1:20 metals)

### 3.3 Margin Guard Implementation
- **Free margin check**: Ensure position uses ≤60% of available margin
- **Margin calculation**: Use `OrderCalcMargin()` for accurate estimation
- **Fallback logic**: Reduce volume if margin insufficient
- **Error handling**: Return 0 volume if margin constraints cannot be met

### 3.4 Risk Clamp Integration
- **Daily room**: Calculate remaining daily loss capacity
- **Overall room**: Calculate remaining overall loss capacity  
- **Risk clamp**: `min(requested_risk, daily_room, overall_room)`
- **Small room guard**: Pause if `room_today < MinRiskDollar`

---

## 4. Equity Guardian Enhancements (`equity_guardian.mqh`)

### 4.1 Real Room Calculations
```cpp
// From spec formulas:
// Room today: (DailyLossCapPct/100) * baseline_today − (baseline_today − current_equity)
// Room overall: (OverallLossCapPct/100) * initial_baseline − (initial_baseline − current_equity)
```

### 4.2 Budget Gate Implementation
- **Current exposure**: Sum open position risk + pending order risk
- **Next trade validation**: `open_risk + pending_risk + next_trade_worst_case ≤ 0.9 * min(room_today, room_overall)`
- **Multi-trade session rule**: For second trade in session, use 0.8 multiplier
- **Floor buffer**: Ensure ≥0.5% baseline buffer after worst-case scenario

### 4.3 Position/Order Caps Enforcement
- **Before any order**: Check all three caps:
  - `OpenPositionsTotal < MaxOpenPositionsTotal`
  - `OpenPositionsBySymbol(sym) < MaxOpenPerSymbol` 
  - `OpenPendingsBySymbol(sym) < MaxPendingsPerSymbol`
- **Real-time counting**: Query actual MT5 positions/orders
- **Symbol-specific**: Count per symbol for per-symbol limits

---

## 5. Session Management (`sessions.mqh`)

### 5.1 Enhanced Session Predicates
- **London session**: `StartHourLO` to `CutoffHour` (default 7-16 server time)
- **New York session**: `StartHourNY` to `CutoffHour` (default 12-16 server time)
- **OR window tracking**: First `ORMinutes` of each session (default 60min)
- **Session state**: Track which session is active per symbol

### 5.2 Opening Range (OR) Tracking
- **M5 bar monitoring**: Track H/L during OR window
- **Per-symbol OR levels**: Store OR_High, OR_Low for each symbol/session
- **OR completion**: Mark when OR window closes
- **Reset logic**: Clear OR levels at session start

### 5.3 Session Governance Integration
- **One-and-Done**: If London win ≥ `OneAndDoneR`, disable NY for all symbols
- **NY Gate**: Allow NY only if day loss ≤ `NYGatePctOfDailyCap * DailyLossCapPct`
- **UseLondonOnly**: Respect input to disable NY session entirely

---

## 6. Meta-Policy Integration (`meta_policy.mqh`)

### 6.1 BWISC/MR Routing Logic
- **Primary = BWISC**: Default strategy selection
- **Confidence comparison**: Compare BWISC vs MR confidence scores
- **Tie-breaker rule**: Choose MR if `BWISC_conf < 0.70 AND MR_conf > 0.80 AND efficiency(MR) ≥ efficiency(BWISC)`
- **Efficiency calculation**: `E[R] / WorstCaseRisk`

### 6.2 MetaPolicy_Choose() Implementation
- **Input validation**: Check both strategy proposals
- **Decision logic**: Apply tie-breaker rules from spec
- **Output**: Return "BWISC", "MR", or "SKIP"
- **Logging**: Record decision rationale for audit

---

## 7. Allocator Integration (`allocator.mqh`)

### 7.1 OrderPlan Structure
```cpp
struct OrderPlan {
    bool     valid;
    string   symbol;
    int      order_type;    // OP_BUY, OP_SELL, OP_BUYSTOP, etc.
    double   volume;
    double   price;
    double   sl;
    double   tp;
    string   comment;
    int      magic;
};
```

### 7.2 Allocator_BuildOrderPlan() Implementation
- **Signal integration**: Take BWISC setup parameters
- **Risk sizing**: Apply ATR-based volume calculation
- **Price calculation**: Determine entry price (market vs pending)
- **SL/TP setting**: Apply ATR multiples and R targets
- **Validation**: Ensure plan passes all gates and caps
- **Magic number**: Generate from `MagicBase + symbol_index`

---

## 8. Testing & Validation

### 8.1 Unit Testing Components
- **BTR/SDR/ORE calculations**: Test with known D1/H1 data
- **Bias formula**: Verify against manual calculations
- **Setup detection**: Test BC/MSC trigger conditions
- **Risk sizing**: Validate volume calculations
- **Position caps**: Test enforcement logic

### 8.2 Integration Testing
- **Full signal flow**: Context → Indicators → BWISC → Risk → Allocator
- **Session transitions**: Test OR tracking, session changes
- **Edge cases**: Handle missing data, calculation errors
- **Memory management**: Verify no leaks in indicator handles

### 8.3 Strategy Tester Validation
- **Setup generation**: Verify ≥1 setup per day (median)
- **Risk compliance**: Ensure no cap violations
- **Performance metrics**: Track setup frequency, bias distribution
- **Log analysis**: Review decision logs for correctness

---

## 9. Implementation Checklist

### Phase 1: Foundation (Days 1-2)
- [ ] Implement real indicator handles in `indicators.mqh`
- [ ] Add session statistics (OR tracking, D1 OHLC)
- [ ] Create BTR/SDR/ORE calculation functions
- [ ] Implement bias score formula

### Phase 2: Signal Engine (Days 3-4)  
- [ ] Complete BC setup detection logic
- [ ] Complete MSC setup detection logic
- [ ] Implement RSI guard
- [ ] Complete `SignalsBWISC_Propose()` function

### Phase 3: Risk Management (Days 5-6)
- [ ] Implement ATR-based position sizing
- [ ] Add margin guard (≤60% free margin)
- [ ] Implement position/order caps enforcement
- [ ] Complete budget gate logic

### Phase 4: Integration (Day 7)
- [ ] Update `Equity_ComputeRooms()` with real calculations
- [ ] Complete `Allocator_BuildOrderPlan()` 
- [ ] Test full signal-to-plan pipeline
- [ ] Validate in Strategy Tester

---

## 10. Success Criteria

### Functional Requirements
- [ ] BWISC generates valid BC/MSC setups based on bias calculations
- [ ] Risk sizing respects equity caps and margin limits
- [ ] Position caps prevent over-exposure
- [ ] Budget gate prevents room violations
- [ ] All calculations handle edge cases gracefully

### Performance Requirements  
- [ ] Setup generation: ≥1 qualified setup/day (median) in forward demo
- [ ] CPU usage: Remains <2% during active trading
- [ ] Memory: No indicator handle leaks
- [ ] Latency: Signal calculation <100ms per symbol

### Compliance Requirements
- [ ] Zero violations of daily/overall drawdown caps
- [ ] Proper session governance (London/NY, One-and-Done)
- [ ] Risk calculations match specification formulas exactly
- [ ] All decisions logged for audit trail

---

## Notes
- **No order placement**: M2 remains logging-only, no broker interactions
- **Stub dependencies**: MR engine, Order Engine remain stubs until M3/M7
- **Error handling**: Graceful degradation on calculation failures
- **Backward compatibility**: Maintain M1 logging and persistence functionality