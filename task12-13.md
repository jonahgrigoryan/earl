# task12-13.md — Phase 3 Tasks 12–13 Implementation Outline (Finalized)

### Scope

- Task 12: Queue Manager for deferred trade modifications during news windows with TTL, idempotency, prioritization, overflow/back‑pressure, persistence/restore, and audit logging.
- Task 13: Trailing logic activating at +1R, adjusting SL by ATR×TrailMult (indicator slot); risk‑reducing only; queued during news and revalidated post‑news.
- No code changes in this step; outline only.

---

### 1) Preparation

- Acceptance (requirements/design):
  - During the T±300s high‑impact news master window, queue SL/TP/trailing; protective exits are allowed and floors override all.
  - **Queue Manager**: Enqueue with TTL (server time), enforce MaxQueueSize and prioritization if enabled, maintain idempotency per `(ticket, action_type)`. Persist queued actions and restore on init with idempotent reconciliation. On window exit, revalidate (UTC news state) vs floors/caps/budget/session and apply. Full audit logging.
  - **Trailing**: Activate once unrealized ≥ +1R (R from entry stop distance). Move SL forward by `ATR×TrailMult` on favorable moves only (never backward), rounding to symbol precision. During news, enqueue; post‑news revalidate and apply. Floors override everything; risk‑reducing bypasses budget gate; caps/sessions respected.
- Config alignment (read from `MQL5/Include/RPEA/config.mqh`, no new constants):
  - `QueueTTLMinutes` (default 5 if unset) — TTL for queued items; read at `OnInit` and cached for queue.
  - `MaxQueueSize` — maximum queued actions retained; used for admission control and to derive an internal per‑tick batch bound.
  - `EnableQueuePrioritization` — if true, enforce tiered priority with FIFO within tiers; else single FIFO.

---

### 2) Interfaces & Modules (proposed)

#### Queue Manager module: `MQL5/Include/RPEA/queue.mqh` (owned by Order Engine; no duplicated state)

- Types
```cpp
enum QueueActionType
  {
     QA_SL_MODIFY = 0,
     QA_TP_MODIFY = 1,
     QA_CLOSE      = 2
  };

enum QueuePriorityTier
  {
     QP_PROTECTIVE_EXIT = 0,
     QP_TIGHTEN_SL      = 1,
     QP_OTHER           = 2
  };

struct QueuedAction
  {
     long               id;            // monotonically increasing identifier
     // Idempotency keys
     long               ticket;
     QueueActionType    action_type;
     // Timing & priority
     datetime           created_at;    // TimeCurrent() when enqueued (server time)
     datetime           expires_at;    // created_at + QueueTTLMinutes
     QueuePriorityTier  priority;      // computed on enqueue
     // Payload
     string             symbol;
     double             new_sl;        // 0 if unchanged
     double             new_tp;        // 0 if unchanged
     string             context;       // strategy context JSON/CSV
     int                retry_count;   // apply attempts (retries reuse order engine policy)
  };
```

- Public API (signatures)
```cpp
bool   Queue_Add(const string symbol,
                 const long ticket,
                 const QueueActionType action_type,
                 const double new_sl,
                 const double new_tp,
                 const string context,
                 long &out_id);

int    Queue_RevalidateAndApply();               // process by priority; returns applied count
int    Queue_CancelExpired();                    // drop expired; returns drop count
bool   Queue_ClearForTicket(const long ticket);  // remove all queued for a ticket
int    Queue_Size();                             // total size across tiers
bool   Queue_CoalesceIfRedundant(const long ticket,
                                 const double current_sl,
                                 const double current_tp);

// Persistence
bool   Queue_SaveOrUpdateOnDisk(const QueuedAction &qa);   // write-through on enqueue/update
bool   Queue_DeleteFromDiskById(const long id);            // remove on success/final drop
int    Queue_LoadFromDiskAndReconcile();                   // OnInit restore; returns loaded count
```

- Internal helpers
```cpp
QueuePriorityTier Queue_ComputePriority(const QueueActionType type,
                                        const double old_sl,
                                        const double new_sl,
                                        const bool is_long);

bool   Queue_RevalidateItem(QueuedAction &qa, string &out_reason_code);
bool   Queue_CheckNewsWindow(const string symbol, string &out_reason_code);     // uses UTC from news.mqh
bool   Queue_CheckRiskAndCaps(const string symbol, const long ticket,
                              const bool is_risk_reducing,
                              string &out_reason_code);                          // floors override; budget bypass for risk-reducing
bool   Queue_CheckSymbolSession(const string symbol, string &out_reason_code);

int    Queue_AdmitOrBackpressure(const QueuedAction &incoming,
                                 string &out_reason_code);  // -1 reject, 0 admitted, >0 evicted count
```

- Persistence details
  - Path: `MQL5/Files/RPEA/state/queue_actions.csv` (CSV with header) — persisted on enqueue/update and delete-on-success/drop.
  - Fields: `id, ticket, action_type, symbol, created_at, expires_at, priority, new_sl, new_tp, context, retry_count`.
  - Idempotency: reconcile by `(ticket, action_type)` and `id` on restore.

#### Trailing logic: `MQL5/Include/RPEA/trailing.mqh` and integration with `order_engine.mqh`

- Scope: single‑leg positions only (no pair‑protect/replication in Tasks 12–13).
- Public API (signatures)
```cpp
bool   Trail_ShouldActivateAtPlus1R(const string symbol, const long ticket);

double Trail_ComputeNewSL(const string symbol,
                          const long ticket,
                          const double atr_from_indicator_slot,
                          const double trail_mult);

void   Trail_HandleOnTickOrTimer();  // scan positions; enqueue/apply per news state

bool   Trail_QueueDuringNews(const string symbol,
                             const long ticket,
                             const double new_sl,
                             const string context,
                             long &out_queue_id);

bool   Trail_ApplyWhenClear(const string symbol,
                            const long ticket,
                            const double new_sl,
                            const string context);
```

- State needed: per‑position entry price and entry SL (for R), last_trail_level, ATR slot value, news window state. Access via existing order engine/indicators utilities.

#### Order Engine touchpoints: `MQL5/Include/RPEA/order_engine.mqh`

- Exact integration points
```cpp
// Called by strategy/trailing to request a modification or protective close
bool OrderEngine_RequestModifySLTP(const string symbol,
                                   const long ticket,
                                   const double new_sl,
                                   const double new_tp,
                                   const string context);

bool OrderEngine_RequestProtectiveClose(const string symbol,
                                        const long ticket,
                                        const string context);

// Timer orchestration invoked from RPEA.mq5 OnTimer
void OrderEngine_ProcessQueueAndTrailing();

// Reentrancy/exec lock
bool OrderEngine_EnterCritical(const string reason);
void OrderEngine_ExitCritical(const string reason);

// Trade transaction hook to keep queue coherent
void OrderEngine_OnTradeTransaction(const MqlTradeTransaction &trans,
                                    const MqlTradeRequest &request,
                                    const MqlTradeResult &result);

// Persistence lifecycle
void OrderEngine_RestoreStateOnInit(); // loads queue and intents from disk, reconciles
```

- Behavior:
  - `OrderEngine_RequestModifySLTP/ProtectiveClose`: if in T±300s news window → `Queue_Add` (persists); protective exits allowed; floors override. Else normalize and apply immediately using existing slippage/retry/backoff policy; risk‑reducing path bypasses budget gate.
  - `OrderEngine_ProcessQueueAndTrailing`: acquires global exec lock; runs queue maintenance then trailing within bounded batch; releases lock.
  - `OrderEngine_OnTradeTransaction`: on close or SL/TP change for `ticket`, call `Queue_ClearForTicket` and `Queue_CoalesceIfRedundant`; persist deletions.
  - `OrderEngine_RestoreStateOnInit`: load persisted queue and intents; drop expired (TTL via server time); coalesce with current platform state; re‑admit respecting `MaxQueueSize` and prioritization policy.

#### Scheduler integration (`MQL5/Experts/FundingPips/RPEA.mq5`)

- `OnInit`: call `OrderEngine_RestoreStateOnInit()` then proceed with normal init.
- `OnTimer` order (explicit):

  1. Budget snapshot (rooms/floors) and NY gate.
  2. News gate evaluation (master T±300s via `news.mqh`).
  3. Queue maintenance: `OrderEngine_ProcessQueueAndTrailing()` which internally does `Queue_CancelExpired()` → `Queue_RevalidateAndApply()`.
  4. Trailing decisions within same critical section: `Trail_HandleOnTickOrTimer()` (enqueue/apply per news state).

---

### 3) Detailed Logic (step‑by‑step)

#### Execution/reentrancy lock

- Global lock within Order Engine to avoid races between `OnTimer` (queue/trailing) and `OnTradeTransaction`.
  - `OrderEngine_EnterCritical/ExitCritical` guard queue scans, applies, trailing, and persistence writes.
  - `OnTradeTransaction` takes the lock briefly to mutate queue and persist deletes/coalesces. If lock busy, skip with `SKIP_BUSY` and let next `OnTimer` reconcile.

#### Queue Manager

- Enqueue path
  - During T±300s news window, queue SL/TP/trailing; protective exits allowed and floors override all.
  - Determine priority: protective close → `QP_PROTECTIVE_EXIT`; SL tighten (risk‑reducing) → `QP_TIGHTEN_SL`; TP‑only/non risk‑reducing → `QP_OTHER`.
  - Reject risk‑increasing requests (e.g., widening SL): `RISK_INCREASING_NOT_ALLOWED`.
  - Compute `expires_at = TimeCurrent() + (QueueTTLMinutes * 60)`.
  - Admission control using `MaxQueueSize`:
    - If size < max → admit; else back‑pressure:
      - If `EnableQueuePrioritization` true → evict oldest from the lowest non‑empty tier strictly lower than incoming; if none, reject incoming.
      - If disabled → evict oldest overall (global FIFO).
    - Persist evictions (`OVERFLOW_EVICT`) and rejections (`OVERFLOW_REJECT`).
  - Idempotency: if `(ticket, action_type)` exists, replace payload/context/priority; preserve `created_at`; update `expires_at` accordingly; persist update.
  - Write‑through persistence: `Queue_SaveOrUpdateOnDisk` for every admit/update.
- Maintenance path (each `OnTimer`, inside critical section)
  - Bound per‑tick work: internal `QUEUE_PROCESS_BATCH = max(1, MaxQueueSize/10)`; not a config constant.
  - `Queue_CancelExpired()` drops items where `TimeCurrent() ≥ expires_at`; persist deletions; reason `DROPPED_TTL`.
  - `Queue_RevalidateAndApply()` by priority tiers (FIFO within tier):
    - Skip items still in news window (UTC check via `news.mqh`) → keep queued, reason `NEWS_WINDOW_BLOCK`.
    - Revalidate in order: floors (override; protective exits allowed) → risk semantics (risk‑reducing bypasses budget gate) → budget gate (others) → caps → symbol/session.
    - Normalize targets: round SL/TP to symbol digits; enforce min stop distance.
    - Apply using existing order engine modify path with market fallback: up to 3 attempts, ~300ms backoff, `MaxSlippagePoints` enforced.
      - On success: remove from memory and disk (`APPLY_OK`).
      - On retriable failure: keep queued, increment `retry_count`, persist update (`APPLY_RETRY`).
      - On permanent failure: drop from memory and disk (`APPLY_FAIL_PERMANENT`).

#### Trailing Manager

- Activation
  - `R = abs(entry_price - entry_sl_at_open)`; activation when unrealized ≥ +1R.
- Step computation (`Trail_ComputeNewSL`)
  - Use ATR from indicator slot; compute direction‑aware `new_sl` as `price_in_favor - sign*ATR*TrailMult`.
  - Monotonic: for longs `new_sl = max(new_sl, last_trail_level)`; for shorts `new_sl = min(new_sl, last_trail_level)`.
  - Round to symbol precision; enforce min stop distance.
- Application
  - In T±300s news window: `Trail_QueueDuringNews(...)` to enqueue SL modify with idempotency; persist via queue; log `QUEUED_NEWS`.
  - Outside news: revalidate (floors/caps/sessions; budget bypass for risk‑reducing), then apply immediately (reuse existing modify path and retry/backoff).

#### OnTradeTransaction hooks

- On position close: `Queue_ClearForTicket(ticket)` and delete from disk.
- On SL/TP changed externally: `Queue_CoalesceIfRedundant(ticket, current_sl, current_tp)` drops queued items that would be no‑ops; persist deletions; log `COALESCE_DROP`.

#### Persistence & restoration (Requirement 8)

- Files under state directory:
  - Queued actions: `MQL5/Files/RPEA/state/queue_actions.csv` — schema above; write‑through updates; delete on success/final drop.
  - Order intents: reuse existing JSON journal `Files/RPEA/state/intents.json` (from Task 2) — do not introduce `order_intents.csv`.
- Intent journal keys (reuse from Task 2):
  - `intent_id` and stable `intent_key` (hash of strategy context per Task 2), alongside `symbol, ticket (if any), action_type, created_at, context`.
- Restore on `OnInit` (`OrderEngine_RestoreStateOnInit`):
  - Load `queue_actions.csv` → dedupe by `(ticket, action_type)` keeping the most recent non‑expired; drop expired via `TimeCurrent()`; coalesce against current platform state (skip if SL/TP already applied or ticket closed); enforce `MaxQueueSize` with prioritization/back‑pressure when re‑admitting; persist resulting set back to disk.
  - Load `Files/RPEA/state/intents.json` → idempotently reconcile with Task 2 intent journal (no duplicates by `intent_key/intent_id`); the queue references intents by `intent_id` in `context` when available for traceability.
- Crash‑safety
  - Write‑through on enqueue/update; remove from disk only after confirmed apply or final drop; use atomic replace pattern (write temp, then rename) where feasible in MQL5 file API.

#### Time and TTL semantics

- TTL computed using server time `TimeCurrent()` at enqueue and on restore.
- Post‑news revalidation uses UTC evaluation via `news.mqh` helpers to determine window exit/entry.

---

### 4) News & Risk Compliance (integration)

- **News invariants**: master T±300s block; queue SL/TP/trailing during window; protective exits allowed; floors override all; post‑news, revalidate and apply.
- **Risk semantics**:
  - Floors override all; protective exits always allowed (even during news).
  - Risk‑reducing changes (tighten SL/protective close) bypass budget gate, but must respect caps and symbol/session.
  - Budget gate and caps enforced for non risk‑reducing changes.

---

### 5) Logging & Audit

- CSV audit fields (augment existing):
  - `queue_id, ticket, symbol, action_type, priority, requested_sl, requested_tp, retry_count, execution_mode(queued|applied|dropped), reason_code, news_window_state, confidence, efficiency, est_value, hold_time, gating_reason, open_risk, pending_risk, next_trade, room_today, room_overall, budget_gate_pass`.
- Reason codes
  - `[QUEUE]` `QUEUED_NEWS, OVERFLOW_EVICT, OVERFLOW_REJECT, DROPPED_TTL, COALESCE_DROP, RISK_INCREASING_NOT_ALLOWED`
  - `[REVALIDATE]` `OK, FAIL_FLOOR, FAIL_BUDGET, FAIL_CAPS, FAIL_SESSION, NEWS_WINDOW_BLOCK`
  - `[APPLY]` `OK, RETRY, FAIL_PERMANENT`
  - `[LOCK]` `SKIP_BUSY`
  - `[STATE]` `SAVE_OK, SAVE_FAIL, LOAD_OK, LOAD_FAIL, RECONCILE_DROP_EXPIRED, RECONCILE_DROP_REDUNDANT`

---

### 6) Tests (to add; not implementing yet)

- `Tests/RPEA/test_queue_manager.mqh`
  - `Queues_DuringNews_NotAppliedImmediately`
  - `Queue_TTLDrop_AfterQueueTTLMinutes`
  - `Queue_OverflowEnforcesPolicy` (prioritization on/off; evict vs reject; FIFO within tier; bounded batch)
  - `Revalidate_PostNews_ApplyOrRemain_WithReason`
  - `Idempotency_ReplacesPayload_PreservesCreatedAt`
  - `Coalesce_OnExternalSLTPChange_DropsObsolete`
  - `Lock_SerializesProcessing_WithOnTradeTransaction`
  - `Persistence_RestoreOnInit_DropsExpired_ResumesProcessing`
- `Tests/RPEA/test_trailing.mqh`
  - `Activates_AtPlus1R_Only`
  - `TrailStep_Equals_ATRtimesTrailMult_Monotonic_NoBackward`
  - `RoundsToSymbolPrecision_RespectsMinStopDistance`
  - `QueuesDuringNews_AppliesPostNews_WithRevalidation`
  - `RiskReducing_BypassesBudgetGate_ButRespectsCapsSessions`
- `Tests/RPEA/test_audit_logging.mqh`
  - `Audit_CSV_Fields_MatchInvariants` (asserts CSV fields include all required invariants)
- `Tests/RPEA/run_automated_tests_ea.mq5`
  - Register new suites following existing harness pattern; deterministic time/ATR stubs (server time for TTL; UTC for news checks); create fixture files under `Tests/RPEA/fixtures/state/` as needed.

---

### 7) Config Usage (no new constants)

- Read once at `OnInit` (and cached) from `config.mqh`:
  - `QueueTTLMinutes` (fallback to 5) → TTL computation.
  - `MaxQueueSize` → admission control and internal per‑tick `QUEUE_PROCESS_BATCH` derivation (no new config).
  - `EnableQueuePrioritization` → toggles tiered queueing semantics.
- Reuse order engine apply settings: slippage cap, retry count=3, ~300ms backoff.

---

### 8) Acceptance Checklist (mapped to requirements)

- Queue Manager
  - Enqueues during T±300s; TTL via `TimeCurrent()`; post‑news revalidation via UTC.
  - Enforces `MaxQueueSize` with prioritization/back‑pressure; FIFO within tiers; bounded per‑tick batch.
  - Idempotency, coalescing on external SL/TP changes, audit logging with reason codes.
  - Persistence: queued actions in `MQL5/Files/RPEA/state/queue_actions.csv` and order intents in `Files/RPEA/state/intents.json`; OnInit restore drops expired and resumes processing; idempotent reconciliation using Task 2 intent journal keys.
- Trailing
  - Activates at +1R; `ATR×TrailMult` from indicator slot; rounds to precision; never widens risk.
  - Queues during news; post‑news apply with revalidation; risk‑reducing bypasses budget gate; floors override all.
- Execution lock prevents races with `OnTradeTransaction`.
- Tests listed and harness wiring noted; includes audit CSV assertion.
- Scheduler order explicit: budget snapshot → news gate → queue maintenance → trailing.

---

### 9) Hold Point

- Stop after this outline. Do not change any source files yet. Await approval before implementation.